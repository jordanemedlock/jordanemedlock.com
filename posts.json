[{"body": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"seive of eratosthenes\" class=\"pull-right\"/><h2>\n    Problem 3 &ldquo;Largest Prime Factor&rdquo;\n  <\/h2>\n  <blockquote>\n    The prime factors of 13195 are 5, 7, 13 and 29. \n    <br/>\n    What is the largest prime factor of the number 600851475143?\n  <\/blockquote>\n<\/div>\n\n<p>This has two major sections &ldquo;Prime&rdquo; and &ldquo;Factor&rdquo;. This means we should define a function to find if a value is prime and another to determine the largest factor, that is also prime. We can use quickly define a factor function using the mod function like we did in problem 1. This time we will have to make it work for any number not just 3 and 5.<\/p>\n\n<pre><code>ghci&gt; let isFactor x n = (mod n x) == 0\n<\/code><\/pre>\n\n<p>In this case we are checking if n is a factor of x. We can use this and the Sieve of Eratosthenes to create a list of all prime numbers. We are going to have to make another version of isFactor that checks if any of the elements of a list are a factor of the number.<\/p>\n\n<pre><code>let isFactorIn xs n = map (isFactor n) xs\n<\/code><\/pre>\n\n<p>This returns a list of booleans each one representing weather or not that number is a factor of n. Try it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isFactorIn [1,2,3,4,5] 10\n[True,True,False,False,True]\ngchi&gt; isFactorIn [1,2,3,4,5] 7\n[True,False,False,False,False]\ngchi&gt; isFactorIn [2,3,5,7,13,17] 23\n[False,False,False,False,False,False]\n<\/code><\/pre>\n\n<p>Notice how if we can use a list of prime numbers we can find out if another number is prime.\nIf every element returned from isFactorIn is False then we know that the number is prime. So we should write a function that figures out if there are any Trues in a list.<\/p>\n\n<pre><code>ghci&gt; let allFalse xs = (length (filter id xs)) &gt; 0\n<\/code><\/pre>\n\n<p>This returns True if all the elements of the list are False. Lets combine them now:<\/p>\n\n<pre><code>ghci&gt; let isPrime primes n = allFalse (isFactorIn (takeWhile (&lt;n) primes) n)\n<\/code><\/pre>\n\n<p>We still need a list of primes to get a list of primes. Thankfully, Haskell is very good at using lists to generate themselves.<\/p>\n\n<pre><code>ghci&gt; let seive xs = (head xs) : (seive (filter (isFactor (head xs)) (tail xs)))\nghci&gt; let primes = seive [2..]\n<\/code><\/pre>\n\n<p>Those are all the primes and they will print forever if you decide to. Now to find the largest prime factor of 600851475143. To do that we can just use filter.<\/p>\n\n<pre><code>ghci&gt; filter (isFactor 600851475143) primes\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>6857<\/pre>\n<\/div>\n\n<p>The last number on that list is our answer!<\/p>", "highlighted": [], "reblog_key": "IeJL5Or5", "format": "markdown", "timestamp": 1435459098, "note_count": 1, "tags": ["haskell", "project euler", "programming", "coding", "problem 3", "computer science", "computers", "puzzle", "challenge"], "trail": [{"content": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"seive of eratosthenes\" class=\"pull-right\"><h2>\n    Problem 3 \u201cLargest Prime Factor\u201d\n  <\/h2>\n  <blockquote>\n    The prime factors of 13195 are 5, 7, 13 and 29. \n    <br>\n    What is the largest prime factor of the number 600851475143?\n  <\/blockquote>\n<\/div>\n\n<p>This has two major sections \u201cPrime\u201d and \u201cFactor\u201d. This means we should define a function to find if a value is prime and another to determine the largest factor, that is also prime. We can use quickly define a factor function using the mod function like we did in problem 1. This time we will have to make it work for any number not just 3 and 5.<\/p>\n\n<pre><code>ghci> let isFactor x n = (mod n x) == 0\n<\/code><\/pre>\n\n<p>In this case we are checking if n is a factor of x. We can use this and the Sieve of Eratosthenes to create a list of all prime numbers. We are going to have to make another version of isFactor that checks if any of the elements of a list are a factor of the number.<\/p>\n\n<pre><code>let isFactorIn xs n = map (isFactor n) xs\n<\/code><\/pre>\n\n<p>This returns a list of booleans each one representing weather or not that number is a factor of n. Try it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi> isFactorIn [1,2,3,4,5] 10\n[True,True,False,False,True]\ngchi> isFactorIn [1,2,3,4,5] 7\n[True,False,False,False,False]\ngchi> isFactorIn [2,3,5,7,13,17] 23\n[False,False,False,False,False,False]\n<\/code><\/pre>\n\n<p>Notice how if we can use a list of prime numbers we can find out if another number is prime.\nIf every element returned from isFactorIn is False then we know that the number is prime. So we should write a function that figures out if there are any Trues in a list.<\/p>\n\n<pre><code>ghci> let allFalse xs = (length (filter id xs)) > 0\n<\/code><\/pre>\n\n<p>This returns True if all the elements of the list are False. Lets combine them now:<\/p>\n\n<pre><code>ghci> let isPrime primes n = allFalse (isFactorIn (takeWhile (<n) primes) n)\n<\/code><\/pre>\n\n<p>We still need a list of primes to get a list of primes. Thankfully, Haskell is very good at using lists to generate themselves.<\/p>\n\n<pre><code>ghci> let seive xs = (head xs) : (seive (filter (isFactor (head xs)) (tail xs)))\nghci> let primes = seive [2..]\n<\/code><\/pre>\n\n<p>Those are all the primes and they will print forever if you decide to. Now to find the largest prime factor of 600851475143. To do that we can just use filter.<\/p>\n\n<pre><code>ghci> filter (isFactor 600851475143) primes\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>6857<\/pre>\n<\/div>\n\n<p>The last number on that list is our answer!<\/p>", "content_raw": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"seive of eratosthenes\" class=\"pull-right\"><h2>\n    Problem 3 \"Largest Prime Factor\"\n  <\/h2>\n  <blockquote>\n    The prime factors of 13195 are 5, 7, 13 and 29. \n    <br>\n    What is the largest prime factor of the number 600851475143?\n  <\/blockquote>\n<\/div>\n\nThis has two major sections \"Prime\" and \"Factor\". This means we should define a function to find if a value is prime and another to determine the largest factor, that is also prime. We can use quickly define a factor function using the mod function like we did in problem 1. This time we will have to make it work for any number not just 3 and 5.\n\n\tghci&gt; let isFactor x n = (mod n x) == 0\n\nIn this case we are checking if n is a factor of x. We can use this and the Sieve of Eratosthenes to create a list of all prime numbers. We are going to have to make another version of isFactor that checks if any of the elements of a list are a factor of the number.\n\n\tlet isFactorIn xs n = map (isFactor n) xs\n\nThis returns a list of booleans each one representing weather or not that number is a factor of n. Try it.\n\nExamples\n\n\tgchi&gt; isFactorIn [1,2,3,4,5] 10\n\t[True,True,False,False,True]\n\tgchi&gt; isFactorIn [1,2,3,4,5] 7\n\t[True,False,False,False,False]\n\tgchi&gt; isFactorIn [2,3,5,7,13,17] 23\n\t[False,False,False,False,False,False]\n\nNotice how if we can use a list of prime numbers we can find out if another number is prime.\nIf every element returned from isFactorIn is False then we know that the number is prime. So we should write a function that figures out if there are any Trues in a list.\n\n\tghci&gt; let allFalse xs = (length (filter id xs)) &gt; 0\n\nThis returns True if all the elements of the list are False. Lets combine them now:\n\n\tghci&gt; let isPrime primes n = allFalse (isFactorIn (takeWhile (<n primes n we still need a list of to get primes. thankfully haskell is very good at using lists generate themselves. ghci> let seive xs = (head xs) : (seive (filter (isFactor (head xs)) (tail xs)))\n\tghci&gt; let primes = seive [2..]\n\nThose are all the primes and they will print forever if you decide to. Now to find the largest prime factor of 600851475143. To do that we can just use filter.\n\n\tghci&gt; filter (isFactor 600851475143) primes\n\n<div class=\"spoilers\">\n<pre>6857<\/pre>\n<\/div>\n\nThe last number on that list is our answer!<\/n>", "is_current_item": true, "blog": {"theme": {"title_font_weight": "bold", "title_color": "#444444", "header_bounds": "", "title_font": "Helvetica Neue", "link_color": "#529ecc", "header_image_focused": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "show_description": true, "show_header_image": true, "header_stretch": true, "body_font": "Helvetica Neue", "show_title": true, "header_image_scaled": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "avatar_shape": "circle", "show_avatar": true, "background_color": "#f6f6f6", "header_image": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg"}, "name": "cs-alloc-init"}, "is_root_item": true, "post": {"id": "122640071116"}}], "id": 122640071116, "post_url": "http://cs-alloc-init.tumblr.com/post/122640071116/problem-3", "recommended_source": null, "state": "published", "reblog": {"comment": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"seive of eratosthenes\" class=\"pull-right\"><h2>\n    Problem 3 &ldquo;Largest Prime Factor&rdquo;\n  <\/h2>\n  <blockquote>\n    The prime factors of 13195 are 5, 7, 13 and 29. \n    <br>\n    What is the largest prime factor of the number 600851475143?\n  <\/blockquote>\n<\/div>\n\n<p>This has two major sections &ldquo;Prime&rdquo; and &ldquo;Factor&rdquo;. This means we should define a function to find if a value is prime and another to determine the largest factor, that is also prime. We can use quickly define a factor function using the mod function like we did in problem 1. This time we will have to make it work for any number not just 3 and 5.<\/p>\n\n<pre><code>ghci&gt; let isFactor x n = (mod n x) == 0\n<\/code><\/pre>\n\n<p>In this case we are checking if n is a factor of x. We can use this and the Sieve of Eratosthenes to create a list of all prime numbers. We are going to have to make another version of isFactor that checks if any of the elements of a list are a factor of the number.<\/p>\n\n<pre><code>let isFactorIn xs n = map (isFactor n) xs\n<\/code><\/pre>\n\n<p>This returns a list of booleans each one representing weather or not that number is a factor of n. Try it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isFactorIn [1,2,3,4,5] 10\n[True,True,False,False,True]\ngchi&gt; isFactorIn [1,2,3,4,5] 7\n[True,False,False,False,False]\ngchi&gt; isFactorIn [2,3,5,7,13,17] 23\n[False,False,False,False,False,False]\n<\/code><\/pre>\n\n<p>Notice how if we can use a list of prime numbers we can find out if another number is prime.\nIf every element returned from isFactorIn is False then we know that the number is prime. So we should write a function that figures out if there are any Trues in a list.<\/p>\n\n<pre><code>ghci&gt; let allFalse xs = (length (filter id xs)) &gt; 0\n<\/code><\/pre>\n\n<p>This returns True if all the elements of the list are False. Lets combine them now:<\/p>\n\n<pre><code>ghci&gt; let isPrime primes n = allFalse (isFactorIn (takeWhile (&lt;n) primes) n)\n<\/code><\/pre>\n\n<p>We still need a list of primes to get a list of primes. Thankfully, Haskell is very good at using lists to generate themselves.<\/p>\n\n<pre><code>ghci&gt; let seive xs = (head xs) : (seive (filter (isFactor (head xs)) (tail xs)))\nghci&gt; let primes = seive [2..]\n<\/code><\/pre>\n\n<p>Those are all the primes and they will print forever if you decide to. Now to find the largest prime factor of 600851475143. To do that we can just use filter.<\/p>\n\n<pre><code>ghci&gt; filter (isFactor 600851475143) primes\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>6857<\/pre>\n<\/div>\n\n<p>The last number on that list is our answer!<\/p>", "tree_html": ""}, "short_url": "http://tmblr.co/ZKPQ8q1oDwldC", "date": "2015-06-28 02:38:18 GMT", "title": "Project Euler - Problem 3 in Haskell", "post_author": "morallyambiguoussentances", "type": "text", "slug": "problem-3", "blog_name": "cs-alloc-init"}, {"body": "<div class=\"preview\"> \n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/9/93/Fibonacci_spiral_34.svg\" alt=\"Fibonacci Spiral\" class=\"pull-right\" width=\"500\"/><h2>\n    Problem 2 &ldquo;Even Fibonacci Numbers&rdquo;\n  <\/h2>\n  <blockquote>\n    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n    <br/>\n    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &hellip; \n    <br/>\n    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n  <\/blockquote>\n<\/div>\n\n<h3>Break it down<\/h3>\n\n<p>The biggest sections we can break this off into are the Fibonacci sequence, and the sum of even-valued terms.<\/p>\n\n<h3>Fibonacci Sequence<\/h3>\n\n<p>The Fibonacci Sequence is defined in mathematicall terms as: Fn = Fn-1 + Fn-2 with the seed values: F1 = 1 and F2 = 1. We can translate this perfectly into Haskell by writting:<\/p>\n\n<pre><code>ghci&gt; let f n = if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)\n<\/code><\/pre>\n\n<p>Try it out<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>ghci&gt; f 1\n1\nghci&gt; f 5\n5\nghci&gt; f 10\n55\nghci&gt; f 50\n12586269025\n<\/code><\/pre>\n\n<p>For the last example it probably took a really long time to run. This is because the version we just made uses too many redundant calculations. If we are going to be creating Fibonacci numbers up to 4 million we will have to come up with a faster function.<\/p>\n\n<p>Lets make it faster. The next definition for Fibonacci is a little confusing so bear with me.<\/p>\n\n<pre><code>ghci&gt; let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n<\/code><\/pre>\n\n<p>This creates an infinite list of all the Fibonacci numbers. So if we want to access an individual element in the Fibonacci sequence we would write fibs !! 50 to get the 50th element. Note that the definition of fibs references fibs in its own definition. This means that it uses the previously generated elements of the list to create the rest of the list. Try this one out with extremely large values.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; fibs !! 1\n1\ngchi&gt; fibs !! 5\n5\ngchi&gt; fibs !! 10\n55\nghci&gt; f 50\n12586269025\n<\/code><\/pre>\n\n<p>Notice how much quicker this one was because there were no redundent calculations.\nNow to put it together. You already have a list of all the elements of Fibonacci, now you just have to find the even ones less than 4 million. For that you can use filter and takeWhile.<\/p>\n\n<pre><code>ghci&gt; let evenFibs = takeWhile (&lt; 4000000) (filter even fibs)\n<\/code><\/pre>\n\n<p>Now sum them.<\/p>\n\n<pre><code>ghci&gt; sum evenFibs\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>4613732<\/pre>\n<\/div>\n\n<p>There you go! Problem 2 in the bag! Now onto problem 3.<\/p>", "highlighted": [], "reblog_key": "uNWchWL6", "format": "markdown", "timestamp": 1435458860, "note_count": 2, "tags": ["haskell", "programming", "project euler", "problem 2", "computer science", "coding", "tutorial", "fibonacci", "fibonacci sequence", "puzzle", "problem"], "trail": [{"content": "<div class=\"preview\"> \n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/9/93/Fibonacci_spiral_34.svg\" alt=\"Fibonacci Spiral\" class=\"pull-right\" width=\"500\"><h2>\n    Problem 2 \u201cEven Fibonacci Numbers\u201d\n  <\/h2>\n  <blockquote>\n    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n    <br>\n    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u2026 \n    <br>\n    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n  <\/blockquote>\n<\/div>\n\n<h3>Break it down<\/h3>\n\n<p>The biggest sections we can break this off into are the Fibonacci sequence, and the sum of even-valued terms.<\/p>\n\n<h3>Fibonacci Sequence<\/h3>\n\n<p>The Fibonacci Sequence is defined in mathematicall terms as: Fn = Fn-1 + Fn-2 with the seed values: F1 = 1 and F2 = 1. We can translate this perfectly into Haskell by writting:<\/p>\n\n<pre><code>ghci> let f n = if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)\n<\/code><\/pre>\n\n<p>Try it out<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>ghci> f 1\n1\nghci> f 5\n5\nghci> f 10\n55\nghci> f 50\n12586269025\n<\/code><\/pre>\n\n<p>For the last example it probably took a really long time to run. This is because the version we just made uses too many redundant calculations. If we are going to be creating Fibonacci numbers up to 4 million we will have to come up with a faster function.<\/p>\n\n<p>Lets make it faster. The next definition for Fibonacci is a little confusing so bear with me.<\/p>\n\n<pre><code>ghci> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n<\/code><\/pre>\n\n<p>This creates an infinite list of all the Fibonacci numbers. So if we want to access an individual element in the Fibonacci sequence we would write fibs !! 50 to get the 50th element. Note that the definition of fibs references fibs in its own definition. This means that it uses the previously generated elements of the list to create the rest of the list. Try this one out with extremely large values.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi> fibs !! 1\n1\ngchi> fibs !! 5\n5\ngchi> fibs !! 10\n55\nghci> f 50\n12586269025\n<\/code><\/pre>\n\n<p>Notice how much quicker this one was because there were no redundent calculations.\nNow to put it together. You already have a list of all the elements of Fibonacci, now you just have to find the even ones less than 4 million. For that you can use filter and takeWhile.<\/p>\n\n<pre><code>ghci> let evenFibs = takeWhile (< 4000000) (filter even fibs)\n<\/code><\/pre>\n\n<p>Now sum them.<\/p>\n\n<pre><code>ghci> sum evenFibs\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>4613732<\/pre>\n<\/div>\n\n<p>There you go! Problem 2 in the bag! Now onto problem 3.<\/p>", "content_raw": "<div class=\"preview\"> \n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/9/93/Fibonacci_spiral_34.svg\" alt=\"Fibonacci Spiral\" class=\"pull-right\" width=\"500\"><h2>\n    Problem 2 \"Even Fibonacci Numbers\"\n  <\/h2>\n  <blockquote>\n    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n    <br>\n    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... \n    <br>\n    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n  <\/blockquote>\n<\/div>\n\n### Break it down\n\nThe biggest sections we can break this off into are the Fibonacci sequence, and the sum of even-valued terms.\n\n### Fibonacci Sequence\n\nThe Fibonacci Sequence is defined in mathematicall terms as: Fn = Fn-1 + Fn-2 with the seed values: F1 = 1 and F2 = 1. We can translate this perfectly into Haskell by writting:\n\n\tghci&gt; let f n = if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)\n\nTry it out\n\nExamples\n\n\tghci&gt; f 1\n\t1\n\tghci&gt; f 5\n\t5\n\tghci&gt; f 10\n\t55\n\tghci&gt; f 50\n\t12586269025\n\nFor the last example it probably took a really long time to run. This is because the version we just made uses too many redundant calculations. If we are going to be creating Fibonacci numbers up to 4 million we will have to come up with a faster function.\n\nLets make it faster. The next definition for Fibonacci is a little confusing so bear with me.\n\n\tghci&gt; let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n\nThis creates an infinite list of all the Fibonacci numbers. So if we want to access an individual element in the Fibonacci sequence we would write fibs !! 50 to get the 50th element. Note that the definition of fibs references fibs in its own definition. This means that it uses the previously generated elements of the list to create the rest of the list. Try this one out with extremely large values.\n\nExamples\n\n\tgchi&gt; fibs !! 1\n\t1\n\tgchi&gt; fibs !! 5\n\t5\n\tgchi&gt; fibs !! 10\n\t55\n\tghci&gt; f 50\n\t12586269025\n\nNotice how much quicker this one was because there were no redundent calculations.\nNow to put it together. You already have a list of all the elements of Fibonacci, now you just have to find the even ones less than 4 million. For that you can use filter and takeWhile.\n\n\tghci&gt; let evenFibs = takeWhile ( sum evenFibs\n\n<div class=\"spoilers\">\n<pre>4613732<\/pre>\n<\/div>\n\nThere you go! Problem 2 in the bag! Now onto problem 3.", "is_current_item": true, "blog": {"theme": {"title_font_weight": "bold", "title_color": "#444444", "header_bounds": "", "title_font": "Helvetica Neue", "link_color": "#529ecc", "header_image_focused": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "show_description": true, "show_header_image": true, "header_stretch": true, "body_font": "Helvetica Neue", "show_title": true, "header_image_scaled": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "avatar_shape": "circle", "show_avatar": true, "background_color": "#f6f6f6", "header_image": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg"}, "name": "cs-alloc-init"}, "is_root_item": true, "post": {"id": "122639801471"}}], "id": 122639801471, "post_url": "http://cs-alloc-init.tumblr.com/post/122639801471/problem-2", "recommended_source": null, "state": "published", "reblog": {"comment": "<div class=\"preview\"> \n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/9/93/Fibonacci_spiral_34.svg\" alt=\"Fibonacci Spiral\" class=\"pull-right\" width=\"500\"><h2>\n    Problem 2 &ldquo;Even Fibonacci Numbers&rdquo;\n  <\/h2>\n  <blockquote>\n    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n    <br>\n    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, &hellip; \n    <br>\n    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\n  <\/blockquote>\n<\/div>\n\n<h3>Break it down<\/h3>\n\n<p>The biggest sections we can break this off into are the Fibonacci sequence, and the sum of even-valued terms.<\/p>\n\n<h3>Fibonacci Sequence<\/h3>\n\n<p>The Fibonacci Sequence is defined in mathematicall terms as: Fn = Fn-1 + Fn-2 with the seed values: F1 = 1 and F2 = 1. We can translate this perfectly into Haskell by writting:<\/p>\n\n<pre><code>ghci&gt; let f n = if n == 1 || n == 2 then 1 else f (n-1) + f (n-2)\n<\/code><\/pre>\n\n<p>Try it out<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>ghci&gt; f 1\n1\nghci&gt; f 5\n5\nghci&gt; f 10\n55\nghci&gt; f 50\n12586269025\n<\/code><\/pre>\n\n<p>For the last example it probably took a really long time to run. This is because the version we just made uses too many redundant calculations. If we are going to be creating Fibonacci numbers up to 4 million we will have to come up with a faster function.<\/p>\n\n<p>Lets make it faster. The next definition for Fibonacci is a little confusing so bear with me.<\/p>\n\n<pre><code>ghci&gt; let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n<\/code><\/pre>\n\n<p>This creates an infinite list of all the Fibonacci numbers. So if we want to access an individual element in the Fibonacci sequence we would write fibs !! 50 to get the 50th element. Note that the definition of fibs references fibs in its own definition. This means that it uses the previously generated elements of the list to create the rest of the list. Try this one out with extremely large values.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; fibs !! 1\n1\ngchi&gt; fibs !! 5\n5\ngchi&gt; fibs !! 10\n55\nghci&gt; f 50\n12586269025\n<\/code><\/pre>\n\n<p>Notice how much quicker this one was because there were no redundent calculations.\nNow to put it together. You already have a list of all the elements of Fibonacci, now you just have to find the even ones less than 4 million. For that you can use filter and takeWhile.<\/p>\n\n<pre><code>ghci&gt; let evenFibs = takeWhile (&lt; 4000000) (filter even fibs)\n<\/code><\/pre>\n\n<p>Now sum them.<\/p>\n\n<pre><code>ghci&gt; sum evenFibs\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>4613732<\/pre>\n<\/div>\n\n<p>There you go! Problem 2 in the bag! Now onto problem 3.<\/p>", "tree_html": ""}, "short_url": "http://tmblr.co/ZKPQ8q1oDvjn-", "date": "2015-06-28 02:34:20 GMT", "title": "Project Euler - Problem 2 in Haskell", "post_author": "morallyambiguoussentances", "type": "text", "slug": "problem-2", "blog_name": "cs-alloc-init"}, {"body": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d7/Leonhard_Euler.jpg\" alt=\"Leonhard Euler\" class=\"pull-right\"/><h2>\n    Problem 1 &ldquo;Multiples of 3 and 5&rdquo;\n  <\/h2>\n  <blockquote>\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. \n    <br/>\n    Find the sum of all the multiples of 3 or 5 below 1000.\n  <\/blockquote>\n<\/div>\n\n<p>The way to approach all programming problems is to break a large problem into smaller ones. If the smaller pieces are still too big, break them down further. You do this until you have a bunch of tiny managable pieces that you just have to fit together.<\/p>\n\n<p>Each of these small pieces is represented using different functions.<\/p>\n\n<h3>Breaking it down<\/h3>\n\n<p>This problem has a few distinct pieces that need to be addressed.<\/p>\n\n<ul><li>&ldquo;Multiples of 3 or 5&rdquo; finding if a number is a multiple of 3 or 5<\/li>\n<li>&ldquo;all the multiples of 3 and 5 below 1000&rdquo; indicates we need a list to store multiples of 3 and 5.<\/li>\n<li>&ldquo;sum&rdquo; find the sum of that list.<\/li>\n<\/ul><h3>Multiple of 3 or 5<\/h3>\n\n<p>For this piece you will make a function to detirmine if a number is a multiple of 3 or 5.<\/p>\n\n<p>We can break this up even further into two functions, one that tests if a number is divisible by 3 and another that tests if its divisble by 5. After that we will combine them. Start with the name and arguments of the function. Name it something memorable and clear like isMultipleOf3. This function will take 1 argument we will call it n and it will be the number we are testing.<\/p>\n\n<p>So far you should have part of a function definition like so:<\/p>\n\n<pre><code>ghci&gt; let isMultipleOf3 n = \n<\/code><\/pre>\n\n<p>Now to find if a number is a multiple of 3 you need to use the mod function. The mod function takes the remainder of one number divided by another. So if the (mod n 3) is equal to 0, then we know n is divisible by 3. Lets plug it in:<\/p>\n\n<pre><code>ghci&gt; let isMultipleOf3 n = (mod n 3) == 0\n<\/code><\/pre>\n\n<p>Done! Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isMultipleOf3 3\nTrue\ngchi&gt; isMultipleOf3 5\nFalse\ngchi&gt; isMultipleOf3 849372648\nTrue\n<\/code><\/pre>\n\n<p>Now for multiples of 5. This one should be very simple just change the 3s in the previous example to 5s.<\/p>\n\n<pre><code>ghci&gt; isMultipleOf5 n = (mod n 5) == 0\n<\/code><\/pre>\n\n<p>See, simple!<\/p>\n\n<p>Now to put them together! Note how we word what we want because it will be very similar to how we write our next function. We want to check if the number &ldquo;is a multiple of 3 or is a multiple of 5&rdquo;.<\/p>\n\n<pre><code>ghci&gt; isMultipleOf3or5 n = (isMultipleOf3 n) || (isMultipleOf5 n)\n<\/code><\/pre>\n\n<p>For our function &ldquo;is a multiple of 3&rdquo; translates into isMultipleOf3 n, &ldquo;or&rdquo; translates into the function ||, and &ldquo;is a multiple of 5&rdquo; translates into isMultipleOf5 n. Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isMultipleOf3or5 3\nTrue\ngchi&gt; isMultipleOf3or5 5\nTrue\ngchi&gt; isMultipleOf3or5 849372648\nTrue\nghci&gt; isMultipleOf3or5 9875378325\nTrue\n<\/code><\/pre>\n\n<p>Now to make a list of all these numbers. This is where our friend filter comes in. To filter the list so that it only includes multiples of 3 and 5 we give the filter function our isMultipleOf3or5 function.<\/p>\n\n<pre><code>ghci&gt; let multiples = filter isMultipleOf3or5 [1..999]\ngchi&gt; multiples\n[3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,57,60,63,65,66,69,70,72,75,78,80,81,84,85,87,90,93,95,96,99,100,102,105,108,110,111,114,115,117,120,123,125,126,129,130,132,135,138,140,141,144,145,...\n<\/code><\/pre>\n\n<p>Woo! It works! We have a list of all multiples of 3 and 5. Now we sum them up with the sum function.<\/p>\n\n<pre><code>gchi&gt; sum multiples\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>233168<\/pre>\n<\/div>", "highlighted": [], "reblog_key": "wKI8fyA2", "format": "markdown", "timestamp": 1435458199, "note_count": 1, "tags": ["haskell", "project euler", "problem 1", "programming", "tutorial", "computer science", "computers"], "trail": [{"content": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d7/Leonhard_Euler.jpg\" alt=\"Leonhard Euler\" class=\"pull-right\"><h2>\n    Problem 1 \u201cMultiples of 3 and 5\u201d\n  <\/h2>\n  <blockquote>\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. \n    <br>\n    Find the sum of all the multiples of 3 or 5 below 1000.\n  <\/blockquote>\n<\/div>\n\n<p>The way to approach all programming problems is to break a large problem into smaller ones. If the smaller pieces are still too big, break them down further. You do this until you have a bunch of tiny managable pieces that you just have to fit together.<\/p>\n\n<p>Each of these small pieces is represented using different functions.<\/p>\n\n<h3>Breaking it down<\/h3>\n\n<p>This problem has a few distinct pieces that need to be addressed.<\/p>\n\n<ul><li>\u201cMultiples of 3 or 5\u201d finding if a number is a multiple of 3 or 5<\/li>\n<li>\u201call the multiples of 3 and 5 below 1000\u201d indicates we need a list to store multiples of 3 and 5.<\/li>\n<li>\u201csum\u201d find the sum of that list.<\/li>\n<\/ul><h3>Multiple of 3 or 5<\/h3>\n\n<p>For this piece you will make a function to detirmine if a number is a multiple of 3 or 5.<\/p>\n\n<p>We can break this up even further into two functions, one that tests if a number is divisible by 3 and another that tests if its divisble by 5. After that we will combine them. Start with the name and arguments of the function. Name it something memorable and clear like isMultipleOf3. This function will take 1 argument we will call it n and it will be the number we are testing.<\/p>\n\n<p>So far you should have part of a function definition like so:<\/p>\n\n<pre><code>ghci> let isMultipleOf3 n = \n<\/code><\/pre>\n\n<p>Now to find if a number is a multiple of 3 you need to use the mod function. The mod function takes the remainder of one number divided by another. So if the (mod n 3) is equal to 0, then we know n is divisible by 3. Lets plug it in:<\/p>\n\n<pre><code>ghci> let isMultipleOf3 n = (mod n 3) == 0\n<\/code><\/pre>\n\n<p>Done! Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi> isMultipleOf3 3\nTrue\ngchi> isMultipleOf3 5\nFalse\ngchi> isMultipleOf3 849372648\nTrue\n<\/code><\/pre>\n\n<p>Now for multiples of 5. This one should be very simple just change the 3s in the previous example to 5s.<\/p>\n\n<pre><code>ghci> isMultipleOf5 n = (mod n 5) == 0\n<\/code><\/pre>\n\n<p>See, simple!<\/p>\n\n<p>Now to put them together! Note how we word what we want because it will be very similar to how we write our next function. We want to check if the number \u201cis a multiple of 3 or is a multiple of 5\u201d.<\/p>\n\n<pre><code>ghci> isMultipleOf3or5 n = (isMultipleOf3 n) || (isMultipleOf5 n)\n<\/code><\/pre>\n\n<p>For our function \u201cis a multiple of 3\u201d translates into isMultipleOf3 n, \u201cor\u201d translates into the function ||, and \u201cis a multiple of 5\u201d translates into isMultipleOf5 n. Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi> isMultipleOf3or5 3\nTrue\ngchi> isMultipleOf3or5 5\nTrue\ngchi> isMultipleOf3or5 849372648\nTrue\nghci> isMultipleOf3or5 9875378325\nTrue\n<\/code><\/pre>\n\n<p>Now to make a list of all these numbers. This is where our friend filter comes in. To filter the list so that it only includes multiples of 3 and 5 we give the filter function our isMultipleOf3or5 function.<\/p>\n\n<pre><code>ghci> let multiples = filter isMultipleOf3or5 [1..999]\ngchi> multiples\n[3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,57,60,63,65,66,69,70,72,75,78,80,81,84,85,87,90,93,95,96,99,100,102,105,108,110,111,114,115,117,120,123,125,126,129,130,132,135,138,140,141,144,145,...\n<\/code><\/pre>\n\n<p>Woo! It works! We have a list of all multiples of 3 and 5. Now we sum them up with the sum function.<\/p>\n\n<pre><code>gchi> sum multiples\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>233168<\/pre>\n<\/div>", "content_raw": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d7/Leonhard_Euler.jpg\" alt=\"Leonhard Euler\" class=\"pull-right\"><h2>\n    Problem 1 \"Multiples of 3 and 5\"\n  <\/h2>\n  <blockquote>\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. \n    <br>\n    Find the sum of all the multiples of 3 or 5 below 1000.\n  <\/blockquote>\n<\/div>\n\nThe way to approach all programming problems is to break a large problem into smaller ones. If the smaller pieces are still too big, break them down further. You do this until you have a bunch of tiny managable pieces that you just have to fit together.\n\nEach of these small pieces is represented using different functions.\n\n### Breaking it down\n\nThis problem has a few distinct pieces that need to be addressed.\n\n - \"Multiples of 3 or 5\" finding if a number is a multiple of 3 or 5\n - \"all the multiples of 3 and 5 below 1000\" indicates we need a list to store multiples of 3 and 5.\n - \"sum\" find the sum of that list.\n\n### Multiple of 3 or 5\n\nFor this piece you will make a function to detirmine if a number is a multiple of 3 or 5.\n\nWe can break this up even further into two functions, one that tests if a number is divisible by 3 and another that tests if its divisble by 5. After that we will combine them. Start with the name and arguments of the function. Name it something memorable and clear like isMultipleOf3. This function will take 1 argument we will call it n and it will be the number we are testing.\n\nSo far you should have part of a function definition like so:\n\n    ghci&gt; let isMultipleOf3 n = \n\nNow to find if a number is a multiple of 3 you need to use the mod function. The mod function takes the remainder of one number divided by another. So if the (mod n 3) is equal to 0, then we know n is divisible by 3. Lets plug it in:\n\n    ghci&gt; let isMultipleOf3 n = (mod n 3) == 0\n\nDone! Now test it.\n\nExamples\n\n    gchi&gt; isMultipleOf3 3\n    True\n    gchi&gt; isMultipleOf3 5\n    False\n    gchi&gt; isMultipleOf3 849372648\n    True\n\nNow for multiples of 5. This one should be very simple just change the 3s in the previous example to 5s.\n\n    ghci&gt; isMultipleOf5 n = (mod n 5) == 0\n\nSee, simple!\n\nNow to put them together! Note how we word what we want because it will be very similar to how we write our next function. We want to check if the number \"is a multiple of 3 or is a multiple of 5\".\n\n    ghci&gt; isMultipleOf3or5 n = (isMultipleOf3 n) || (isMultipleOf5 n)\n\nFor our function \"is a multiple of 3\" translates into isMultipleOf3 n, \"or\" translates into the function ||, and \"is a multiple of 5\" translates into isMultipleOf5 n. Now test it.\n\nExamples\n\n    gchi&gt; isMultipleOf3or5 3\n    True\n    gchi&gt; isMultipleOf3or5 5\n    True\n    gchi&gt; isMultipleOf3or5 849372648\n    True\n    ghci&gt; isMultipleOf3or5 9875378325\n    True\n\nNow to make a list of all these numbers. This is where our friend filter comes in. To filter the list so that it only includes multiples of 3 and 5 we give the filter function our isMultipleOf3or5 function.\n\n    ghci&gt; let multiples = filter isMultipleOf3or5 [1..999]\n    gchi&gt; multiples\n    [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,57,60,63,65,66,69,70,72,75,78,80,81,84,85,87,90,93,95,96,99,100,102,105,108,110,111,114,115,117,120,123,125,126,129,130,132,135,138,140,141,144,145,...\n\nWoo! It works! We have a list of all multiples of 3 and 5. Now we sum them up with the sum function.\n\n    gchi&gt; sum multiples\n<div class=\"spoilers\">\n<pre>233168<\/pre>\n<\/div>", "is_current_item": true, "blog": {"theme": {"title_font_weight": "bold", "title_color": "#444444", "header_bounds": "", "title_font": "Helvetica Neue", "link_color": "#529ecc", "header_image_focused": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "show_description": true, "show_header_image": true, "header_stretch": true, "body_font": "Helvetica Neue", "show_title": true, "header_image_scaled": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg", "avatar_shape": "circle", "show_avatar": true, "background_color": "#f6f6f6", "header_image": "http://static.tumblr.com/617347605d7e2923d19e415f31a1f1e1/hvtuxfb/uPimuuci0/tumblr_static_wah.jpg"}, "name": "cs-alloc-init"}, "is_root_item": true, "post": {"id": "122639074126"}}], "id": 122639074126, "post_url": "http://cs-alloc-init.tumblr.com/post/122639074126/problem-1", "recommended_source": null, "state": "published", "reblog": {"comment": "<div class=\"preview\">\n  <img src=\"https://upload.wikimedia.org/wikipedia/commons/d/d7/Leonhard_Euler.jpg\" alt=\"Leonhard Euler\" class=\"pull-right\"><h2>\n    Problem 1 &ldquo;Multiples of 3 and 5&rdquo;\n  <\/h2>\n  <blockquote>\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. \n    <br>\n    Find the sum of all the multiples of 3 or 5 below 1000.\n  <\/blockquote>\n<\/div>\n\n<p>The way to approach all programming problems is to break a large problem into smaller ones. If the smaller pieces are still too big, break them down further. You do this until you have a bunch of tiny managable pieces that you just have to fit together.<\/p>\n\n<p>Each of these small pieces is represented using different functions.<\/p>\n\n<h3>Breaking it down<\/h3>\n\n<p>This problem has a few distinct pieces that need to be addressed.<\/p>\n\n<ul><li>&ldquo;Multiples of 3 or 5&rdquo; finding if a number is a multiple of 3 or 5<\/li>\n<li>&ldquo;all the multiples of 3 and 5 below 1000&rdquo; indicates we need a list to store multiples of 3 and 5.<\/li>\n<li>&ldquo;sum&rdquo; find the sum of that list.<\/li>\n<\/ul><h3>Multiple of 3 or 5<\/h3>\n\n<p>For this piece you will make a function to detirmine if a number is a multiple of 3 or 5.<\/p>\n\n<p>We can break this up even further into two functions, one that tests if a number is divisible by 3 and another that tests if its divisble by 5. After that we will combine them. Start with the name and arguments of the function. Name it something memorable and clear like isMultipleOf3. This function will take 1 argument we will call it n and it will be the number we are testing.<\/p>\n\n<p>So far you should have part of a function definition like so:<\/p>\n\n<pre><code>ghci&gt; let isMultipleOf3 n = \n<\/code><\/pre>\n\n<p>Now to find if a number is a multiple of 3 you need to use the mod function. The mod function takes the remainder of one number divided by another. So if the (mod n 3) is equal to 0, then we know n is divisible by 3. Lets plug it in:<\/p>\n\n<pre><code>ghci&gt; let isMultipleOf3 n = (mod n 3) == 0\n<\/code><\/pre>\n\n<p>Done! Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isMultipleOf3 3\nTrue\ngchi&gt; isMultipleOf3 5\nFalse\ngchi&gt; isMultipleOf3 849372648\nTrue\n<\/code><\/pre>\n\n<p>Now for multiples of 5. This one should be very simple just change the 3s in the previous example to 5s.<\/p>\n\n<pre><code>ghci&gt; isMultipleOf5 n = (mod n 5) == 0\n<\/code><\/pre>\n\n<p>See, simple!<\/p>\n\n<p>Now to put them together! Note how we word what we want because it will be very similar to how we write our next function. We want to check if the number &ldquo;is a multiple of 3 or is a multiple of 5&rdquo;.<\/p>\n\n<pre><code>ghci&gt; isMultipleOf3or5 n = (isMultipleOf3 n) || (isMultipleOf5 n)\n<\/code><\/pre>\n\n<p>For our function &ldquo;is a multiple of 3&rdquo; translates into isMultipleOf3 n, &ldquo;or&rdquo; translates into the function ||, and &ldquo;is a multiple of 5&rdquo; translates into isMultipleOf5 n. Now test it.<\/p>\n\n<p>Examples<\/p>\n\n<pre><code>gchi&gt; isMultipleOf3or5 3\nTrue\ngchi&gt; isMultipleOf3or5 5\nTrue\ngchi&gt; isMultipleOf3or5 849372648\nTrue\nghci&gt; isMultipleOf3or5 9875378325\nTrue\n<\/code><\/pre>\n\n<p>Now to make a list of all these numbers. This is where our friend filter comes in. To filter the list so that it only includes multiples of 3 and 5 we give the filter function our isMultipleOf3or5 function.<\/p>\n\n<pre><code>ghci&gt; let multiples = filter isMultipleOf3or5 [1..999]\ngchi&gt; multiples\n[3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,57,60,63,65,66,69,70,72,75,78,80,81,84,85,87,90,93,95,96,99,100,102,105,108,110,111,114,115,117,120,123,125,126,129,130,132,135,138,140,141,144,145,...\n<\/code><\/pre>\n\n<p>Woo! It works! We have a list of all multiples of 3 and 5. Now we sum them up with the sum function.<\/p>\n\n<pre><code>gchi&gt; sum multiples\n<\/code><\/pre>\n\n<div class=\"spoilers\">\n<pre>233168<\/pre>\n<\/div>", "tree_html": ""}, "short_url": "http://tmblr.co/ZKPQ8q1oDsyDE", "date": "2015-06-28 02:23:19 GMT", "title": "Project Euler - Problem 1 in Haskell", "post_author": "morallyambiguoussentances", "type": "text", "slug": "problem-1", "blog_name": "cs-alloc-init"}]